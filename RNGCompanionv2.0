#Requires AutoHotkey v2.0
#SingleInstance Force
#NoTrayIcon
#MaxThreads 255

; Global variables
global running := false
global screenWidth := A_ScreenWidth ? A_ScreenWidth : 1920  ; Default to 1920 if undefined
global screenHeight := A_ScreenHeight ? A_ScreenHeight : 1080  ; Default to 1080 if undefined
global killSwitchHotkey := "^+X"  ; Ctrl + Shift + X to stop
global startHotkey := "^+S"  ; Ctrl + Shift + S to start
global currentState := "Idle"  ; Initial state
global spinDuration := 15000  ; Spin for 15 seconds
global clickFrequency := 400  ; Click every 400ms (2.5 times per second)
global spinSpeed := 4000  ; Adjustable speed for spinning actions

global robloxWindowTitle := "Roblox ahk_exe RobloxPlayerBeta.exe"  ; Adjust to the Roblox window title
global guiWindow := Gui()
global btnStartScript := guiWindow.Add("Button", "x20 y200 w150 h30 cYellow BackgroundBlack", "Start Script")
global btnStopScript := guiWindow.Add("Button", "x220 y200 w150 h30 cYellow BackgroundBlack", "Stop Script")
global statusText := guiWindow.Add("Text", "x20 y250 w360 h30 cBlack", "🐝 Status: Ready")
global lastMouseX := 0
global lastMouseY := 0
global lastHeartbeat := 0  ; Last heartbeat time to check script responsiveness
global robloxHwnd := 0  ; Roblox window handle
global LastRobloxWindow := 0
global LastMainHeartbeat := 0
global MacroState := 0
global windowPosX := 0
global windowPosY := 0

guiWindow.Add("Text", "x10 y10 w380 h100 cRed BackgroundYellow Center", "WARNING: This macro controls the mouse and keyboard, moves the camera, and spams clicks to help you farm breakables. Press Ctrl + Shift + X to stop at any time.")

SetTitleMatchMode(2)  ; Match Roblox by partial title
DetectHiddenWindows(true) ; Ensure we can detect hidden windows

; Set coordinate mode
CoordMode("Mouse", "Screen") ; Coordinates are relative to the screen
CoordMode("Pixel", "Screen") ; Coordinates for pixel-related operations are also relative to the screen

; Show the GUI
guiWindow.Show("w400 h350")  ; Set window size
guiWindow.Title := "🐝 Roblox AutoScript by BeeBrained"

; Restore previous window position
guiWindow.OnEvent("Close", SaveWindowPosition)
if (windowPosX && windowPosY) {
    guiWindow.Move(windowPosX, windowPosY)
}

; Bind functions to button events
btnStartScript.OnEvent("Click", StartScript)
btnStopScript.OnEvent("Click", KillScript)

; Set up hotkeys
Hotkey(killSwitchHotkey, KillScript)  ; Ctrl+Shift+X to stop
Hotkey(startHotkey, StartScript)  ; Ctrl+Shift+S to start

; Use SendEvent mode for compatibility with Roblox
SendMode("Event")

; Start the script with a 5-second delay and initial center click in Roblox
StartScript(*) {
    global running, currentState, statusText, btnStartScript, btnStopScript, screenWidth, screenHeight, robloxWindowTitle, lastMouseX, lastMouseY, lastHeartbeat, robloxHwnd, LastMainHeartbeat, MacroState
    robloxHwnd := WinExist(robloxWindowTitle)
    if robloxHwnd {
        running := true
        btnStartScript.Enabled := false  ; Disable start button
        btnStopScript.Enabled := true  ; Enable stop button

        ; Delay 5 seconds before starting
        statusText.Value := "Waiting 5 seconds before starting..."
        Sleep(5000)

        ; Activate Roblox window and click in the center
        statusText.Value := "Activating Roblox window and clicking in the center..."
        if WinExist(robloxWindowTitle) {
            WinActivate(robloxWindowTitle)  ; Activate the Roblox window
            Sleep(500) ; Wait for the window to activate
            MouseMove(screenWidth * 0.5, screenHeight * 0.5, 10)
            Sleep(200)
            Click("left down")
            Sleep(50)
            Click("left up")
            Sleep(200) ; Pause to simulate a human-like delay
        }

        ; Save the last mouse position
        MouseGetPos(&lastMouseX, &lastMouseY)
        lastHeartbeat := A_TickCount  ; Record the last heartbeat time
        LastMainHeartbeat := A_TickCount  ; Record the main heartbeat time

        ; Transition to the next state
        currentState := "RightClickDrag"
        SetTimer(MainLoop, 20)  ; Start the main loop with more frequent checks
        statusText.Value := "Script started! Press Ctrl+Shift+X to stop."
        MacroState := 2  ; Set macro state to active
    } else {
        MsgBox("Roblox window is not active. Please make sure it's active and try again.")
    }
}

; Stop the script safely
KillScript(*) {
    global running, currentState, statusText, btnStartScript, btnStopScript, lastMouseX, lastMouseY, MacroState
    running := false
    SetTimer(MainLoop, 0)  ; Stop the loop
    btnStartScript.Enabled := true  ; Enable start button
    btnStopScript.Enabled := false  ; Disable stop button
    currentState := "Idle"
    statusText.Value := "Script stopped."
    MacroState := 0  ; Set macro state to inactive

    ; Restore the last mouse position
    MouseMove(lastMouseX, lastMouseY, 10)

    ; Close any running instance of the script
    ExitApp
}

; Main loop controlling game states
MainLoop(*) {
    global running, currentState, screenWidth, screenHeight, robloxWindowTitle, lastHeartbeat, robloxHwnd, LastMainHeartbeat, LastRobloxWindow, MacroState
    robloxHwnd := WinExist(robloxWindowTitle)
    currentTime := A_TickCount

    if (!running || !robloxHwnd) {
        KillScript()  ; Immediately stop if Roblox window is not active
        return
    }

    ; Heartbeat check to ensure script is running properly
    if ((currentTime - LastMainHeartbeat > 120000) || (currentTime - lastHeartbeat > 60000)) {  ; Timeout conditions
        KillScript()  ; Stop script if no heartbeat detected
        MsgBox("Script stopped due to inactivity or timeout.")
        return
    }
    LastMainHeartbeat := currentTime  ; Update main heartbeat

    ; Handle each game state with separate functions
    if (currentState = "RightClickDrag") {
        RightClickDrag()
    } else if (currentState = "SpinAndClick") {
        SpinAndClick()
    }
}

; State: Right-click drag to adjust camera horizontally
RightClickDrag() {
    global currentState, screenWidth, screenHeight, statusText, robloxWindowTitle, clickFrequency, robloxHwnd, LastRobloxWindow
    statusText.Value := "Bot action: Right-click dragging"

    ; Ensure actions are performed in the Roblox window
    if robloxHwnd {
        WinActivate(robloxWindowTitle)  ; Activate the Roblox window
        Sleep(500) ; Wait for the window to activate

        ; Move mouse to starting position
        MouseMove(screenWidth * 0.5, screenHeight * 0.25, 10)
        Sleep(400)

        ; Start right-click drag
        Click("right down")
        Sleep(200)  ; Hold the right mouse button for a bit

        ; Drag the mouse horizontally to simulate camera movement
        MouseMove(screenWidth * 0.75, screenHeight * 0.25, 50)
        Sleep(500)  ; Wait while dragging
        MouseMove(screenWidth * 0.25, screenHeight * 0.25, 50)
        Sleep(500)  ; Wait while dragging

        ; Release right mouse button
        Click("right up")
        Sleep(400)

        ; Move mouse back to starting position
        MouseMove(screenWidth * 0.5, screenHeight * 0.25, 20)
        Sleep(400)

        ; Update heartbeat for Roblox window
        LastRobloxWindow := A_TickCount
    }

    ; Transition to the next state: Spin and click
    currentState := "SpinAndClick"
}

; State: Spin the camera and send inputs periodically
SpinAndClick() {
    global spinDuration, clickFrequency, spinSpeed, currentState, screenWidth, screenHeight, statusText, robloxWindowTitle, robloxHwnd, LastRobloxWindow
    statusText.Value := "Bot action: Spinning and clicking"

    startTime := A_TickCount
    while (A_TickCount - startTime < spinDuration) {
        robloxHwnd := WinExist(robloxWindowTitle)
        if (!robloxHwnd) {
            KillScript()  ; Immediately stop if Roblox window is not active
            return
        }

        ; Simulate spinning the camera by moving the mouse
        MouseMove(screenWidth * 0.5, screenHeight * 0.5, 10)  ; Move mouse to center
        Sleep(spinSpeed)  ; Slow down the spin
        MouseMove(screenWidth * 0.75, screenHeight * 0.5, 10)  ; Spin to the right
        Sleep(spinSpeed)  ; Slow down the spin
        MouseMove(screenWidth * 0.25, screenHeight * 0.5, 10)  ; Spin to the left
        Sleep(spinSpeed)  ; Slow down the spin

        ; Periodic left-clicks while spinning
        Click("left down")
        Sleep(50)
        Click("left up")
        Sleep(clickFrequency)
    }

    ; Transition back to RightClickDrag state after spinning
    currentState := "RightClickDrag"
    LastRobloxWindow := A_TickCount  ; Update last active time for the Roblox window
}

; Save window position before closing
SaveWindowPosition(*) {
    global guiWindow, windowPosX, windowPosY
    guiWindow.GetPos(&windowPosX, &windowPosY)
    ExitApp
}

; Walk function to simulate adaptive movement
WalkSmooth(n) {
    global robloxHwnd
    if robloxHwnd {
        steps := n * 10  ; Number of small steps to take
        stepDuration := 100  ; Duration for each step (ms)
        loop steps {
            MouseMoveAdd(2, 0)  ; Move mouse incrementally
            Sleep(stepDuration / steps)
        }
    }
}

; Function to move mouse incrementally
MouseMoveAdd(deltaX, deltaY) {
    MouseGetPos(&x, &y)
    MouseMove(x + deltaX, y + deltaY, 0)
}

; Get the Roblox window handle
GetRobloxHWND() {
    if (hwnd := WinExist("Roblox ahk_exe RobloxPlayerBeta.exe"))
        return hwnd
    else if (WinExist("Roblox ahk_exe ApplicationFrameHost.exe")) {
        ControlGetHwnd(&hwnd, "", "ApplicationFrameInputSinkWindow1")
        return hwnd
    }
    else
        return 0
}
